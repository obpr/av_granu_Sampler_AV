COMMAND,OPERATOR,ALIAS(S),ARGUMENT(S),PARAMETERS,CATEGORY,DEFAULT,DESCRIPTION,MENU,GUI SHORTCUT,COMMENTS,USE,EXPLANATION,EXAMPLE 1,EXAMPLE 2,PRESET
:a,|,,% | % | %...,% = symbol float or list,database,clear,define the whole database,no,no,This overwrites all previous database entries.,Use this to define the whole database at once.,Look in the text box popup to see what happens to these messages,:a first message | second message | third message | fourth message,:a 1 | | 4, :e 5 :a -open :v 0 :pr 2
:a,,,%1 %2,%1 = float = term‚ %2 = symbol float or list,database,clear,define single field of database,no,no,Note that this command will not work as a creation argument. To define a specific term of the database using creation arguments‚ you must use bars ( | ).,Use this to define a single database field.,Look in the text box popup to see what happens to these messages,:a 1 a message, :a 3 another message, :a -open :v 0 :pr 2
:a,-open,-edit,,,database,n/a,open text box to edit database,messages → x-axis → edit,no,The text edit tool must be saved (ctrl+s).,Use this tool to edit the database manually.,,:a -open,:a -clear,:a first message | second message | third message | fourth message :v 0 :pr 2
:a,-clear,,,,database,n/a,clear the database,messages → x-axis → clear,no,This cant be undone!,Clear all messages from the database.,,:a -open,:a -clear,:a first message |  second message | third message | fourth message :v 0 :pr 2
:a,-scramble,,{% %...},% = float = database term,database,n/a,rearrange the specified fields in the database randomly,no,no,Specify the terms to scramble as arguments‚ or give no arguments to scramble all terms.The rearrangement is random and might turn out the same as before‚ especially with a small number of fields.,This is useful ie. for scrambling a melody.,':a -scramble 1 3 4' rearranges the 1st‚ 3rd and 4th field numbers. Ie. the 1st field might be moved to the 4th‚ the 4th to the 3rd‚ etc. If no arguments are specified‚ all fields are scrambled.,:a -scramble,:a -scramble 1 3 4,:a one | two | three | four :a -open :v 0 :pr 2
:a,+,+ - * or /,%1 {%2} {%3},%1 = value‚ %2 = term‚ %3 = field (floats),database,n/a,perform arithmetic on a database term,no,double (tripple...) click on symbol atom and drag up / down,If the term is unspecified‚ it will be interpreted as the current term. If the line number is unspecified‚ it will be interpreted as the current selected line (ie the one that flashes black in the toggle array). Note that only float terms are counted—symbols are left unaffected.,Use this to modify float terms in the database.,':a * 3 4 2' multiplies by 3 the 4th term of the 2nd field. ':a + 1' adds 1 to the first term of whichever database field is selected. Use the arrow keys to change this selection.,:a + 1,:a * 3 4 2, :a 10 20 30 | 40 50 60 70 :a -open :v 0 :pr 2 :e 5 :x 1 2 3 4 
:a,++,,{%1} %2,%1 = float = term‚ %2 = symbol float or list,database,n/a,accumulate a database term,no,no,If the line number is unspecified (ie. if there is no float proceeding the ‘++’ symbol)‚ it will be interpreted as the current selected line (ie the one that flashes black in the toggle array).,Use this to add text to the end of one of the database terms.,Watch the database to see the text accumulate.,:a ++ 3 4 5,:a ++ some text,:v 0 :e 5 :a -edit :x 1 2 3 4 5
:a,*.,,%,% = float = ID number,database,n/a,read from another contexts database,no,no,This allows you to select another contexts database for plaback instead of this contexts own. Note that it will also clear the :a database.,This is useful because it allows you to store 'master' melodies which you can play back in different ways across several different contexts.,The number corresponds to another contexts ID number. Nothing much will happen in this example‚ since no other contexts are open.,:a *. 2,:a *. 3,:v 0
:b,,,,,,,define the y-axis database,,,The :a and :b database commands have identical syntax. Everything listed under the :a help boxes applies also to :b.,,,,,:v 0
:c,,colour color,%,% = float = PD color value,ID,11,set context colour,ID → colour,no,The numbers argument is the same as regular PD colors. Positive numbers are presets (1-30 repeating) and negative numbers are RGB values.,Context colour schemes have no effect other than aesthetic.,,:c 15,:c -10300,:v 0
:d,,delay time cycle,%,% = float = seconds,time,0,set context cycle duration in seconds,no,float atom (top left),Negative time values will reverse the context cycle. Note that the cycle time might also be effected by the coefficient (:k) and random time mode (:E),Set the cycle duration.,,:d 10,:d -2,:d 4 :x 1 2 4 :v 0 :pr 2
:d,m,M minute minutes,%,% = float = minutes,time,n/a,set context cycle duration in minutes,no,no,Negative time values will reverse the context cycle. Note that the cycle time might also be effected by the coefficient (:k) and random time mode (:E),Use this operator for convenience. Note that it is not saved—it just converts the number to seconds.,,:d m 2,:d m 3,:v 0
:d,h,H hour hours,%,% = float = seconds,time,n/a,set context cycle duration in hours,no,no,Negative time values will reverse the context cycle. Note that the cycle time might also be effected by the coefficient (:k) and random time mode (:E),Use this operator for convenience. Note that it is not saved—it just converts the number to seconds.,,:d h 1,:d h 0.5,:v 0
:d,+,+ - * or /,%,% = float = value,time,n/a,perform arithmetic on cycle duration,no,no,,This can be used to alter timings in a defined way.,,:d - 1, :d * 2,:d 2 :v 0 :pr 2
:e,,,%,% = float = database field,database,1,define the limit of the :a database,messages → x-axis → limit,no,The :a database contains as many fields as there are toggles on the x-axis‚ but not all of them are necessarily read. This setting determines how far along the :a database the x-axis toggles will read. A blank database field will give a bang.,':e 1' (default) means that only the first field is ever read. This means that the context will always send the same message‚ regardless of which toggle fires. If the x-axis contains 9 toggles‚ ':e 8' means that every toggle will deliver its own unique message (the 9th toggle belong to the y-‚ not the x-axis). This is useful for playing melodies or sending complex messages. In the same context‚ ':e 4' will read the first four fields and then repeat the last one for toggles 5-8.,Look at the context symbol atom to see which database entry is accessed. Changing the :e setting will change how many fields are read. (Note that this example starts with the default :e 1).,:e 4,:e 2,:a one | two | three | four :x 1 2 3 4 5 :i 5 1.5 :d 2 :s :v 0 :pr 2
:f,,,%,% = float = database field,database,1,define the limit of the :b database,messages → y-axis → limit,no,This works the same as the ':e' command.,,** probmlem here: the burst message isnt properly setting the message atom.,:f 4,:f 1,:b one | two | three | four :y 1 2 3 4 :i 5 1.5 :d 2 :L linear :s :v 0 :pr 2
:g,,gui GUI,%,% = float = state (-1‚ 0‚ 1),general,0,set context GUI,other → more → miscellaneous → gui off,right click + properties,:g 1 calls the properties menu‚ while :g 0 calls the normal GUI. :g -1 turns the GUI off and deletes/prevents from loading a significant portion of the patch which runs the GUI. The context continues to function as normal but consumes fewer CPU resources‚ a bit like a power saving mode.,Use :g -1 in cases where a context is embedded or when you will have no need to edit its settings manually. Note that this cannot be undone by sending a :g 0 message. If you want to turn the GUI back on‚ you will have to recreate the context without the :g -1 creation argument. (Note further that creation arguments are not live updated inside the object‚ so if you want to return to the GUI in a context whose state has changed‚ you have to save‚ reload‚ and then delete the :g -1 argument.),:g (no argument) will switch between :g 0 and :g 1. :g-1 will turn the GUI off (you'll have to close and re-open this help patch if you want it back!),:g,:g -1,:v 0 :pr 2
:h,,quantity,%,% = float = burst toggle number,burst,0,define the quantity of  burst toggles,burst → quantity → define,no,:h 0 (default) means 'all' toggles. :h is overwritten by the random and progression settings (:p and :l) and by the 'which' setting (:o),Use this to determine how many burst toggles will fire at the end of the next context cycle. Note that only selected toggles can fire‚ so ':h5' will set 5 toggles to be fired only if there are five or more open.,Count how many toggles fire each cycle to see the effect of the :h setting,:h 3,:h 1,:i 5 1 :y = 1 2 3 4 :d 1 :s :v 0 :pr 2
:i,,,% %...,% = values‚ count = no. of x-axis toggles,toggles,clear,define all of the toggle-floats on the x-axis,no,no,0 is interpreted as blank. This will only work when the arguments are euqal to‚ or one less than‚ the number of toggles on the x-axis. The 'one less than' rule helps to avoid confusion regardling the bottom-right toggle. Note that a decimal place indicates an ID number‚ ie. '4.5' becomes 'c4'.,Use this to define the whole float array at once.,Note that negative toggle-floats have a special function—see the FAQ entry.,:i 1 2 3 4 5,:i -2 0 -5 0 0,:x 1 2 3 4 5 :v 0 :pr 2
:i,,,%1 %2 %1 %2...,%1 = toggle position‚ %2 = value (floats),toggles,n/a,define toggle-floats individually on the x-axis,no,double click on a toggle and scroll up or down,A single pair is the most common use‚ but any number of pairs can be specified.  Note that a decimal place indicates an ID number‚ ie. '4.5' becomes 'c4'.,Use this to define toggle floats individually.,The second example changes the 1st toggle to -4‚ the 2nd toggle to -5‚ and the 3rd toggle to -6. Note that negative toggle-floats have a special function—see the FAQ entry.,:i 2 3,:i 1 -4 2 -5 3 -6,:x 1 2 3 4 5 :i 1 1 1 1 1 :v 0 :pr 2
:i,+ or -,,%1 %2,%1 = value‚ %2 = toggle number (floats),toggles,n/a,perform arithmetic on toggle-floats individually,no,no,,,':i – 4 2' subtracts 4 from the second toggle-float. Note that negative toggle-floats have a special function and arent really negative‚ hece the addition. See the FAQ entry.,:i + 2 3,:i - 4 2,:x 1 2 3 4 5 :i 1 1 1 1 1 :v 0 :pr 2
:i,s,swap,% %,% = float = toggle position,toggles,n/a,switch the values of two toggle-floats,no,double click on a toggle and scroll left or right to switch adjascent floats,,Use this to alter a context network (or a melody) in a defined way.,':i s 2 5' switches the float values of the 2nd and 5th toggles.,:i s 1 2,:i s 2 5,:x 1 2 3 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:i,> or <,,%,% = float = value,toggles,n/a,shift the whole float-array n places to the left / right,no,no,,Use this to offset a pattern of floats.,':i > 1' shifts the toggle array 1 place to the right‚ so ie. '1 2 3 4 5' becomes '5 1 2 3 4'. The middle toggle is off‚ so appears blank.,:i > 1,:i < 2,:x 1 2 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:i,>> or <<,,%,% = float = value,toggles,n/a,shift the float-array together with the toggle array n places to the left / right,no,no,This is identical to the ':x >> f' command.,This is more useful than >‚ which moves the float array independently of the toggle array. The difference is hard to describe but visually intuitive.,':i << 2' shifts the float and selection arrays 2 places to the left.,:i >> 1,:i << 2,:x 1 2 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:i,x,,% % ...,same as :i,toggles,n/a,define toggle floats at the same time as the toggle array,no,double click on a toggle and scroll left or right to switch adjascent floats,This command sets the toggle array (on-off) at the same time as the toggle float values.,This is useful for quickly defining a pattern or array‚ as you dont have to consider :i values separately from the :x.,compare this to using only the :i command,:i x 2 3,:i x 1 0 3 4,:v 0
:i,-l,,{%} ...,% = float = value‚ followed by any other :i arguments,toggles,n/a,excepts the last toggle(s) from a :i command,no,no,The -l operator is used in conjunction with other :i commands. It protects the last toggle‚ so that it is not changed by the command. The -l command can take an opotional float argument‚ specifying the number of toggles from the back which should be protected. If no argument is specified‚ the default number is 1.,Use this if you want to rotate or clear toggles while leaving the last one intact (ie. if it is being used for a loop).,Watch the last toggle in this example. It is unaffected by the commands because of the -l operator.,:i -l >>,:i -l 3 clear,:v 0 :i 1 2 3 4 5 :x 1 2 3 5
:i,clear,,,,toggles,n/a,clear toggle float array,no,no,This sets all toggle floats back to 0.,,,:i 1 2 3 4 5,:i clear,:i x 1 3 4 5 :v 0 :pr 2
:i,scramble,,{% %...},% = float = toggle float number,toggles,n/a,rearrange the specified toggle floats randomly,no,no,Specify the toggles to scramble as arguments‚ or give no arguments to scramble all toggles. The rearrangement is random and might turn out the same as before‚ especially with a small number of fields.,This is useful ie. for scrambling a melody.,':i scramble 1 3 5' rearranges the 1st‚ 3rd and 5th terms. ':i scramble' rearranges all terms.,:i scramble 1 3 5,:i scramble,:i x 1 2 3 4 5 :v 0 :pr 2
:i,all,,%,% = float = value,toggles,n/a,define all toggle floats in the array,no,no,This sets all toggle floats in the array to the specified value or pattern.,Use this if you are using one Context to start another one on every beat of the pattern.,,:i all 5,:i all 2 1,:x 1 2 3 4 5 :v 0
:i,pairs,,%1 %2 %1 %2...,%1 = toggle position‚ %2 = value (floats),toggles,n/a,define toggle-floats individually on the x-axis,no,no,This forces Context to interpret the :i values in pairs.,This command would be useful to prevent Context from interpreting the values into the whole array in the case that the number of input values is the same as the number of toggles.,,:i 1 3 2 4,:i pairs 1 3 2 4,:x 1 2 3 4 5 :v 0
:j,,,,,,,defined y-axis toggle floats,,,The :i and :j array commands have identical syntax. Everything listed under the :i help boxes applies also to :j.,,,,,:v 0 :pr 2
:k,,,%,% = float = value (not zero),time,1,define a multiplier or divider for the delay time,timing → calculation → factor,no,This works in conjunction with the coefficient mode‚ :K.,Use this to set a unit other than seconds for the time atom.,,:k 3,:k 1,:x 5 :i 5 1.5 :d 1 :K 1 :s :v 0 :pr 2
:k,,,% %...,% = float = time (seconds),time,n/a,store a custom map for map calculation,timing → calculation → map list,no,This stores a custom list of cycle time values to be selected by the :d value when :K 4 is on. When :d is 0‚ the first value on the list will be selected. When :d is 2‚ the second value will be selected‚ etc. If the :d value is higher than the number of items on the list then the cycle time value rolls back to :d itself.,Use this if you want custom time mappings that cannot be calculated.,Load the :k list and turn :K 4 on and you will see that the cycle times correspond to the numbers in the list. Notice that when :d is 5 the cycle time is 5‚ since there are only 4 numbers on the list.,:K 4,:k 4 5 8 9,:v 0 :E 1 :x 5 :i 5 1.5 :d 5 :s :pr 2
:l,,,%,% = float = percentage,burst,0,randomize the quantity of burst toggles,burst → quantity → random,no,This setting works as a percentage. 0 means that the burst quantity (:h) is definitive and 100 means that it is totally random. Numbers in between describe varying degrees on uncertainty‚ so that the burst quantity will deviate from :h with :l likelihood‚ according to Gaussian distribution. 101 gives even distribution through an 'urn' generator‚ meaning that all available numbers will be used once before the urn is reset‚ like pulling numbers out of a bag. The urn can be reset manually using the 'bump l' command. Note that if :p is set to a non-integer‚ the random mean position will not reset each cycle‚ meaning that the random deviations will center around the same point.,Use this setting to add uncertainty in a context network.,,:l 100,:l 10,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 2 :s :v 0 :pr 2
:l,-open,-edit,,,burst,n/a,edit random distribution array,burst → quantity → edit random,no,This command opens the array which defines the probabilities for the :l setting. Normally you will see a Bell curve here (if :l is greater that 0 and less than 100)‚ but you can draw in a curve to define a new range of probabilities. Unfortunately‚ any changes you make here are unsavable.,Use this to define custom probabilities for the burst quantity.,Open the array and draw in your own curve. You will see the changes reflected in the number of burst toggles that fire.,:l -open,:l 20,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 2 :s :v 0 :pr 2 :l 30
:m,,advance,%,% = float = state (0‚ 1),burst,1,determine whether the burst set auto-advances after every cycle,burst → auto advance,no,This command turns off the auto-advance for burst selection. When it is on‚ a new set of burst toggles is calculated after every context cycles. When off‚ a new set on toggles is not calculated‚ unless a 'bump' command is received.,Use this to to hold the current burst selection.,While :m 0 is set‚ the toggle selection wont advance unless the context receives a 'bump' message. When :m 1 is set‚ toggle selection advances each burst cycle.,bump,:m,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 1 :m 0 :P 1 :s :v 0 :pr 2
:n,,tag name,%1 %2...,% = symbol = tag,ID,clear,define ID tags,ID → tags,no,Context receives all messages sent to 'tag' and sends messages sent to 'tag-'. So you could send a message to the context from the example using [send drum] and receive messages from it using [receive cymbal-]. Note that assigning and removing tags can cause audio glitches.,Use tags to define groups of contexts‚ ie. 'percussion' for all the 'drums' and 'cymbals'. One context can have any number of tags‚ and a tag can be shared between any number of contexts.,':n drum cymbal' assigns the tags 'drum' and 'cymbal'.,:n tag-1 tag-2,:n drums cymbal,:X 10 :v 0 :pr 2
:n,+,tag name,%1 %2...,% = symbol = tag,ID,n/a,add or remove ID tags,ID → tags,no,The + operator indicates that the given symbols should be added or subtracted to the tag list. If a new symbol matches an existing tag it will be subtracted‚ and if not added. Causes audio glitches.,Note that the + operator is not necessary when editing from within the menu‚ where typed symbols are automatically added or removed.,,:n + jam,:n + cheese,:X 10 :n jam bread :v 0 :pr 2
:n,=,tag name,%1 %2...,% = symbol = tag,ID,n/a,define ID tags,ID → tags,no,The = operator defines an exact list of tags‚ just as the :n command with no operator. Causes audio glitches.,Note that this operator is only needed inside the menu‚ where symbols are added or removed by default.,No example given (use the menu).,,,:v 0
:n,-clear,tag name,,,ID,n/a,clear ID tags,ID → clear tags,no,This causes audio glitches.,Use this to clear all tags.,,:n -clear,,:X 10 :n ' unwanted tags ' :v 0 :pr 2
:o,,which,% %...,% = float = toggle number,burst,1,define an exact burst set,burst → selection → define,select burst toggles while idle (not savable),This will force the given toggles despite other burst settings‚ and defines a new mid point for random and progression deviations.,Use this to force a given path in the context network‚ or put it as a creation argument to specify the first outcome.,Choose exactly which toggles will fire at the end of the next burst. Note that in this example‚ auto-advance is off (:m 0) to prevent the burst selection from updating.,:o 2,:o 1 3 5,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :m 0 :h 1 :d 1 :s :v 0 :pr 2
:p,,,%,% = float = value,burst,0,define an arithmetic progression for the burst quantity,burst → quantity → progression,no,This determines an arithmetic progression on the number of burst toggles that are selected each cycle. Positive and negative numbers are accepted. Note that non-integer numbers have a special effect on the :l setting.,Use this to make a context network increase in activity.,Look at how many toggles are firing each cycle.,:p 1,:p 2,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :h 1 :d 1 :s :v 0 :pr 2
:q,,,%,% = float = state (0‚ 1),time,1,set a minimum for random cycle times,timing → random options → minimum,no,This setting only has effect in conjunction with :E 1,By default‚ a random cycle time might return as zero. Use this setting if you want to raise the bar of the minimum value of random cycle timing.,Here‚ random timing is on (:E 1) and the maximum time is 4 (:d 4). The :q value is 0 by default‚ meaning that zeros are allowed in the random timing. When the cycle time turns zero‚ the context stops. This is because the context safety mechanism rejects any instant feedback (this can be turned off with :z 0). When :q is set to 1 or 2‚ this value becomes the new minimum for random cycle times.,:q 1,:q 2,:x 5 :i 5 1.5 :d 4 :E 1 :s :v 0 :pr 2
:r,,record,,no arguments = default record,recording,,record data into Context in real time,no,no,There are many different options for recording. The :r command by itself selects the default‚ which is recording from the inlets to the Pattern toggle-array. Information can also be recorded to the toggle-float array and the message database.,Use this for live input patterns for context‚ or to have context sample itself. See helpfiles/recording.pd for more details.,Press the :r button repeatedly in a rhythmic way. You will see the pattern appear along the x-axis as you create it.,,:r,:X 9 :d 4 :v 0
:r,-source,,%,% = inlet / self / symbol / c float,recording,inlet,set the source of a recording,no,no,The -source operator determines whether the recording should come from Context’s inlets or from some other source. ‘self’ indicates that the source should be the receive channels (ie [send c1]. ‘any-symbol’ sets up a custom receive channel‚ ie [send any-symbol]. ‘c 3’ indicates that the source should be another Context. Here‚ the source is taken from the other Context’s internal commands‚ allowing you to record its operation.,Use this if you are setting up dynamic record systems which record via send channels‚ from midi controllers‚ etc.,You won’t see much in this example‚ unless you create a new object [send $0-c1] or [send drums] and send messages to it during the recording.,:r -source drums,:r -source self,:X 9 :d 4 :v 0
:r,-trigger,,%,% = float = state (0‚ 1),recording,0,determine when the recording starts,no,no,The -trigger operator determines whether the recording starts immediately (0) or when the first input is received (1).,Use this to cue up a recording without starting it.,To understand the difference between the two‚ make a recording without the trigger by pressing ‘:r -trigger 0’ repeatedly‚ then make a recording with the trigger.,:r -trigger 0,:r -trigger 1,:X 9 :d 4 :v 0
:r,-first,,%,% = float = state (0‚ 1),recording,0,determine what should happen to the first toggle when the recording starts,no,no,When -first is 1‚ the first toggle will automatically be triggered during the recording. When -first is 0‚ the first toggle will be left alone.,Quite often‚ a recording is triggered by the same message which is then later recorded (ie. by an ‘:r’ message). The -first operator lets you decide how you want the recording to proceed when it receives the first ‘:r’ command.,To understand the difference between the two‚ make a recording without the -first option by pressing ‘:r -first 0’ repeatedly‚ then make a recording with the -first option.,:r -first 0,:r -first 1,:X 9 :d 4 :v 0
:r,-exclude,,% %,% = any list,recording,blank,set a list of messages to be excluded from a recording,no,no,Any incoming message can be recorded by Context (not just an ‘:r’ message). The -exclude operator gives you the option of excluding certain messages.,It might be useful to exclude messages such as ‘:s’ (start) or ‘:x’.,Start the recording with the ‘:r’ message. If you continue to press ‘:r’‚ the recording will respond‚ but if you press ‘not-me’ then it will not‚ since this message has been excluded.,not-me,:r -exclude not-me,:X 9 :d 4 :v 0
:r,-output,,%,% = float = state (0‚ 1),recording,0,allow recording messages to pass through Context,no,no,When a message is recorded‚ it is muted by default (-output 0)‚ but with -output 1 you can allow the incoming messages to pass through Context and be sent as outgoing messages as they are being recorded.,Use this if you want to record a pattern live into a Context and have it be heard.,Watch the console to see the difference between these two settings as you make a recording by pressing the :r button repeatedly.,:r -output 0,:r -output 1,:X 9 :d 4 :v 0 :pr 1
:r,-playback,,%,% = float = state (0‚ 1),recording,0,play pattern messages as usual during the recording,no,no,By default (-playback 0)‚ the playback of usual Context pattern messages is muted during recording‚ but you can allow it to occur as it usually would using the ‘-playback 1’ operator.,Use this if you want to record one pattern on top of another.,Watch the console to see the difference between these two settings as you make a recording by pressing the :r button repeatedly.,:r -playback 0,:r -playback 1,:X 9 :d 4 :v 0 :pr 1
:r,-messages,,%,% = float = state (0‚ 1),recording,0,record data into the pattern message database,no,no,By default (-message 0)‚ a recording doesn’t affect the message database. With -message 1‚ the message database will be updated with whatever message is received during the recording. Note that any incoming ‘:r’ message is interpreted by the message database as a bang.,Use this to record a melody‚ or to record a series of Context commands.,Use the ‘:r -messages 1’ box to start the recording. Press the other button repeatedly during the recording and watch the message database.,:r -messages,any old message,:X 9 :d 4 :v 0 :a -edit
:r,-prepend,,% %,% = any list,recording,blank,prepend custom text to the database recording,no,no,You can use this to alter the incoming message by prepending any text to it as it is recorded.,This will only work if the ‘-messages 1’ operator is also used.,Use the ‘:r -messages 1 -prepend cats’ box to start the recording. Press the other button repeatedly during the recording and watch the message database.,:r -messages 1 -prepend cats,dogs,:X 9 :d 4 :v 0 :a -edit
:r,-append,,% %,% = any list,recording,blank,append custom text to the database recording,no,no,You can use this to alter the incoming message by appending any text to it as it is recorded.,This will only work if the ‘-messages 1’ operator is also used.,Use the ‘:r -messages 1 -append cats’ box to start the recording. Press the other button repeatedly during the recording and watch the message database.,:r -messages 1 -append cats,dogs,:X 9 :d 4 :v 0 :a -edit
:r,-pattern,,%,% = float = state (0‚ 1),recording,1,allow recording to alter pattern toggles,no,no,By default (-pattern 1)‚ a recording will flip toggles. This operator allows you to prevent a recording from affecting the toggles at all (-pattern 0).,Use this in conjunction with ‘-messages 1’ if you want to record messages but not affect the toggles.,Use the ‘:r -pattern 0 -messages 1’ box to start the recording and the other box to send messages during the recording. Notice that the messages change but the toggles don’t.,:r -pattern 0 -messages 1,some message,:X 9 :d 4 :v 0 :a -edit
:r,-toggleprep,,%,% = symbol = + or -,recording,blank,force toggles on or off during recording,no,no,By default‚ a message received during recording will turn a toggle on or off‚ depending on its current state. This operator lets you change that behaviour‚ so that a recording can only turn toggles on (+) or off (-).,Use this if you want to add to or subtract from a current recording without making any other changes.,Record using the ‘:r -toggleprep 1’ button by pressing it repeatedly. Then use the ‘:r -toggleprep 0’ button to clear the toggles just recorded. Notice that ‘-toggleprepe 1’ can only turn toggles on while ‘toggleprep 0’ can only turn them off.,:r -toggleprep 1,:r -toggleprep 0,:X 9 :d 4 :v 0
:r,-lock,,%,% = float = state (0‚ 1),recording,1,ensure a toggle can only be changed once during a recording,no,no,By default (-lock 1)‚ a recording can only change each toggle once during the recording cycle. Turning this feature off (-lock 0) you can affect a single toggle any number of times so long as the cursor is hanging over it.,Use this if you want to be able to cancel out mistakenly recorded messages.,Make a recording with the ‘:r -lock 0’ button by clicking on it repeatedly very fast. You will see that each toggle can turn on or off. Then make a recording with the ‘lock 1’ box. Now each toggle can only turn on or off once.,:r -lock 1,:r -lock 0,:X 9 :d 4 :v 0
:r,-floats,,%,%= state (0‚ 1‚ c #‚ symbol),recording,0,determine whether toggle-floats are affected during a recording,no,no,By default (-floats 0)‚ recorded messages have no affect on the toggle-floats. With ‘-floats c 5’‚ the toggle float will be set to 5 each time a recording message is sent. With ‘-floats 1’‚ floats will be recorded dynamically. The first float occurring in the incoming message will be recorded. With any symbol set as an argument (ie. ‘:r -floats me’)‚ the recording will search for the symbol ‘me’ in all incoming messages and then find the next float.,Use this if you want to record a melody into the toggle-floats.,Start the recording with ‘:r -floats 1’ and then set the toggle-float array using the other message.,:r -floats 1,message 3,:X 9 :d 4 :v 0
:r,-floatprep,,%,% = float = state (0‚ 1),recording,1,interpret toggle-floats as float-connects,no,no,By default (-floatprep 0)‚ incoming numbers are recorded as normal toggle-floats. You can record them as float-connects using ‘-floatprep 1’,Use this if you want to set float-connections with a recording.,Start the recording using the ‘:r -floatprep 1 -floats 1’ message and record messages using the other box. Compare the toggle-float array to the example given in ‘:r -floats’,:r -floatprep 1 -floats 1,message 2,:X 9 :d 4 :v 0
:r,-delay,,%,% = float = milliseconds,recording,0,set a delay between the position of the cursor and the record position,no,no,By default (-delay 0)‚ the “recording head” moves in line with the cursor during a recording. You can introduce an offset using a -delay message. Positive numbers move the recording position behind‚ while negative numbers move it ahead.,You can use this to compensate for buffer time if you are recording in using a MIDI instrument.,Try recording with the two -delay messages by pressing them repeatedly to compare the difference between positive and negative numbers. Note that it wouldn’t normally make sense to set such a large delay‚ but it makes the example more clear.,:r -delay 1000,:r -delay 1000,:X 9 :d 4 :v 0
:r,-interrupt,,% %,% = any :r operator,recording,n/a,set new :r settings in the middle of a recording,no,no,Normally a recording has its parameters set from the first :r message and remains static until the end. You can change the settings mid cycle using an ‘:r -interrupt’ message.,Use this if you want to change a recording before it reaches the end of its cycle.,Start the recording using the ‘:r’ button and interrupt it using ‘:r -interrupt -lock 0’. You can confirm that the -lock setting mas changed.,:r,:r -interrupt -lock 0,:X 9 :d 4 :v 0
:r,-stop,,,,recording,n/a,halt a recording,no,no,You can stop a recording during its cycle using ‘:r -stop’,Use this to cancel a recording.,Stat the recording using the ‘:r’ button and stop it using the ‘:r -stop’ button.,:r,:r -stop,:X 9 :d 4 :v 0
:s,,start,,,operation,n/a,start a context cycle,no,double click on canvas area,Cable and float connections are equivalent to the :s message.,Use this to start a context automatically.,,:s,start,:x 1 2 :d 1 :v 0 :pr 2
:s,,start,%,% = float or symbol,operation,n/a,start a context cycle,no,no,Arguments do not affect a start message‚ but can be useful in conjunction with the rules list.,See helpfiles → 14_rules.pd,Here‚ 'start' will be allowed but 'start 2' will not. This is defined by a rule (go to properties → other → rules).,start,start 2,:v 0 :d 2 :x = 4 3 2 1 :I 1 :ex ' 1 :s equals 2 || c- '
:s,d,start,%,% = float = time index (ms),operation,n/a,start a context cycle after a delay,no,no,This will start the Context cycle after a given delay‚ as specified by the argument (in milliseconds). It should be compatible with other :s arguments‚ but it must be the first one.,Use this to start a context after a delay.,Look at the delay between sending the message and Context responding,:s d 1000,:s d 1000 p 3,:v 0 :d 2 :x 1 2 3 4
:s,p,start,%,% = float = toggle number,operation,n/a,start a context at a particular toggle point along the pattern axis,no,no,The float corresponds to the position of the toggles along the pattern axis.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,Look at the position on the x-axis floats to see where it starts.,:s p 3,:s p 8,:: long :d 4 :x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :v 0 :pr 2
:s,p,start,% %,% = float = toggle number,operation,n/a,start a context‚ and schedule its stopping‚ at a particular point,no,no,Floats correspond to positions of the toggles along the pattern axis. If the first float is bigger than the first then the context will play in reverse.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,Look at the position on the x-axis floats to see where it starts and stops,:s p 3 6,:s p 15 10,:: long :d 4 :x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :v 0 :pr 2
:s,s,start,%,% = float = time index (ms),operation,n/a,start a context at a particular time index along the timeline,no,no,The float corresponds to a particular time index (in milliseconds) along the timeline. If the context cycle time is altered‚ the time index will change correspondingly.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,Change the time cyce (top left atom) to understand s operator.,:s s 1000,:s s 2400,:: long :d 4 :x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :v 0 :pr 2
:s,s,start,% %,% = float = time index (ms),operation,n/a,start a context‚ and schedule its stopping‚ at a particular time index,no,no,The floats correspond to particular time indexes (in milliseconds) along the timeline. If the context cycle time is altered‚ the time indexes will change correspondingly. If the first float is bigger than the first then the context will play in reverse.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,Change the time cyce (top left atom) to understand s operator.,:s s 1000 3000,:s s 3400 1800,:: long :d 4 :x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :v 0 :pr 2
:s,m,start,%,% = float = marker number,operation,n/a,start a context at a particular marker,no,no,The float corresponds to the ID number of a [marker] object embedded in the Context timeline.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,No example given—see 'embedding.pd' (warning: this patch takes several minutes to load).,,,:v 0
:s ,m,start,% %,% = float = marker number,operation,n/a,start a context‚ and schedule its stopping‚ at a particular marker,no,no,The floats correspond to the ID numbers of [marker] objects embedded in the Context timeline.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,No example given—see 'embedding.pd' (warning: this patch takes several minutes to load).,,,:v 0
:t,,,%,% = float = state (0‚ 1),general,0,determine how context responds when its cycle is interrupted,other → more → miscellaneous  → interruption,no,When this is on‚ context will restart if it is interrputed in the middle of its cycle. When off‚ context will not allow interruption until it has reached the end of its cycle.,Use this to freeze a particular context once it has been started.,Start the context rapidly several times. Then turn click :t 0 and do it again. Notice the difference in behaviour.,start,:t 0,:d 2 :v 0 :pr 2
:u,,bank,%,% = float = bank term,bank,1,retrieve a context state from the storage bank,no,double press and hold shift and click on y-axis toggles,Each Context has a storage bank which is capable of storing multiple Context states. This command jumpts to a new term from the bank‚ which loads a new pre-set (unless the term is blank). Any further changes to the context will be saved in that slot (see bank saving).,The GUI selector allocates as many terms in the bank as there are toggles on the y-axis‚ but you can create more by using this command and editing the bank list (:A open). Use the [bank] object to define a different list of settings for the bank to store (default :x and :i).,Here the states saved in the bank are toggles and cycle time‚ but they could be anything.,:u 1,:u 2,:d 1 :x = 1 :y = 1 :ba ' :x = 1 :y = 1 :d 1 || :x = 1 2 3 :y = 1 2 3 :d 2 ' :v 0 :pr 2
:u,,bank,,,bank,n/a,cycle through terms of storage bank,no,no,Sending a :u command without any arguments jumps to the next bank term. Note that this includes bank terms that are empty. If you want to skip empty terms‚ you can delete them by editing the bank list (:A -open) and deleting empty lines (ie. semi-colons).,This is useful for creating a Cotnext which changes state each time it finishes a cycle.,Here the y-axis toggle sends a message ':u' every time it is hit‚ signalling the bank term to advance. The result is that the x-axis toggles change after every cycle. Pressing ':u manually advances the state‚ while ':u 0' resets it.,:u,:u 0,:d 2 :x 1 5 :ba ' :x = 1 5 || :x = 1 2 5 || :x = 2 3 5 ' :i 5 1.5 start :y = 1 :b ' . :u ' :v 0 :pr 2 :A 0
:v,,saving,%,% = float = state (0‚ 1),saving,1,determine whether new settings will be saved,other → state → auto save,no,Warning: This might crash in conjunction with content auto-saving.,Turn this off if you dont want new context states to be saved to the file‚ ie. if the context gets dynamically changed during playback but you want its original state to remain the same.,No example is given because the effect isnt very visible. However‚ it should be pointed out that all the context used in this example has :v 0‚ to prevent any changes being saved.,,,:v 0 :pr 2
:w,,,%,% = float = state (0‚ 1),burst,0,determines whether random burst quantities can wrap,burst → quantity → wrap,no,,When there is a small amount of random deviation to the number of burst toggles (ie. :l 10)‚ the number will follow a 'drunken walk' pattern. This setting determines whether it hits a 'wall' at the end or whether it wraps back around‚ ie. If the number of toggles can randomly go from 1 to the highest number in one step or not.,,:w 1,:w 0,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :l 10 :d 1 :s :v 0 :pr 2
:x,,,% %...,% = float = toggle number,toggles,n/a,turn toggle(s) on the x-axis on or off,no,click on toggles,This is equivalent to banging each toggle.,This command turns toggles on if they are off and off if they are on.,,:x 1 2 3,:x 2 3 4,:v 0 :pr 2
:x,+,,% %...,% = float = toggle number,toggles,n/a,turn toggle(s) on the x-axis on,no,no,This is equivalent to sending a 1 to each toggle.,This command turns toggles on if they are off. If a toggle was already off‚ no action is taken.,Note that these commands have no effect if the toggle(s) are already on.,:x + 1 2 3,:x + 2 3 4,:x 1 :v 0 :pr 2
:x,-,,% %...,% = float = toggle number,toggles,n/a,turn toggle(s) on the x-axis off,no,no,This is equivalent to sending a 0 to each toggle.,This command turns toggles off if they are on. If a toggle was already on‚ no action is taken.,Note that these commands have no effect if the toggle(s) are already on.,:x - 1 2 3,:x - 2 3 4,:x 1 3 4 5 :v 0 :pr 2
:x,=,:x def,% %...,% = float = toggle number,toggles,=,define a set of x-axis toggles,no,no,Sending a blank ':x =' clears the toggle array.,This command defines exactly a set of toggles to turn on. All other toggles are turned off.,,:x = 1 2,:x = 2 3 4 5,:x 2 3 4 :v 0 :pr 2
:x,> or <,,%,% = float = value,toggles,n/a,shift the whole toggle array f places to the left / right,no,no,,Use this to offset a pattern.,Notice how the toggle pattern moves without the floats.,:x > 1,:x < 2,:x 1 2 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:x,>> or <<,,%,% = float = value,toggles,n/a,shift the float array toggether with the toggle array,no,no,This is identical to the ':i >> f' command.,This is more useful than >‚ which moves the toggle array independently of the float array. The difference is hard to describe but visually intuitive.,Notice how the toggle pattern and the floats move together.,:x >> 1,:x << 2,:x 1 2 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:x,-l,,{%} ...,% = float = value‚ followed by any other :i arguments,toggles,n/a,excepts the last toggle(s) from a :x command,no,no,The -l operator is used in conjunction with other :x commands. It protects the last toggle‚ so that it is not changed by the command. The -l command can take an opotional float argument‚ specifying the number of toggles from the back which should be protected. If no argument is specified‚ the default number is 1.,Use this if you want to rotate or clear toggles while leaving the last one intact (ie. if it is being used for a loop).,Watch the last toggle in this example. It is unaffected by the commands because of the -l operator.,:x -l <,:x -l clear,:v 0 :x 1 2 4 5
:x,clear,0,,,toggles,n/a,clear the toggle array,no,no,This rests all toggles.,,,:x 1 2 3 4 5,:x clear,:x 1 2 3 4 5 :v 0 :pr 2
:x,all,,,,toggles,n/a,turn all toggles on,no,no,This turns all toggles in the array on.,Use this to quickly turn the entire array on.,,:x all,:x clear,:v 0
:x,inverse,,,,toggles,n/a,inverse all toggles,no,no,This turns off all toggles that are currently on and on all toggles that are currently off.,Use this to inverse toggles without having to click on all of them.,,:x inverse,:x 2 4,:v 0 :x 1 2 3
:y,,,,,,n/a,define y-axis toggles,,,The :x and :y commands have identical syntax. Everything listed under the :x help boxes applies also to :y.,,,,,:v 0
:z,,safety,%,% = float = duration (ms),timing,10,define a threshold below which Context cannot loop itself,timing → more → safety limit,no,Context networks often form feedback loops‚ and this can lead to stack overflows‚ especially when the accumulated cycle time is 0. :z turns on (by default) two safety features which prevent this. 1: The minimum cycle time of a context is clipped to 10ms‚ not zero. This means that loops of 0 time cannot occur. 2: When a context is started‚ its input is blocked for the same period of time (10ms). This likewise prevents context from entering into infinite loops‚ ie. If the first toggle of the pattern array references itself.,You might want to turn the safety off if you decide you definitely want a context of 0ms. But you do so at your own risk! Be prepared for stack overflows.,Do you really want to see a stack overflow? Then turn safety off (:z 0) and press start. A feedback loop is created because context restarts itself after 0ms.,:z 0,start,:x 1 :i 1 1 :d 1 :pr 2
:A,,,%,% = float = state (0‚ 1),bank,0,determines whether the context state is auto-saved to the bank,other → preset bank → auto save,no,When this is on‚ every change that is tracked by the bank will trigger the bank to save.,If you turn this off‚ the bank will recall a context state but not update it in the bank. This can be useful if the context has been updated and you want to reload its origin point.,This context modifies its pattern at the end of every cycle (the :b database contains the message ':x (?8 + 1)' ). With bank auto-saving turned off (:A 0)‚ calling the bank (:u 1) will recall the original pattern‚ since the pattern is not updating. With auto-saving on (:A 1)‚ calling the bank will have no effect.,:A,:u 1,:X 9 :x 1 3 5 7 9 :i 9 1.5 :d 2 :v 0 :y 1 :s :b ' . :x (?8 + 1) ' :A 0 :ba ' :x = 1 3 5 7 9 ' :pr 2
:A,-save,,,,bank,n/a,save the current context state to the bank,other → preset bank →save now,no,,Use this to save a context state if you have turned auto-saving off (:A 0).,This context modifies its pattern at the end of every cycle. Since bank auto-saving is of (:A 0)‚ you can recall the original patten by pressing :u 1 and set a new 'origin by pressing :A -save.,:A -save,:u 1,:X 9 :x 1 3 5 7 9 :i 9 1.5 :d 2 :v 0 :y 1 :s :b ' . :x (?8 + 1) ' :A 0 :ba ' :x = 1 3 5 7 9 ' :pr 2
:A,-open,-edit,,,bank,n/a,open a text dialogue to manually edit bank,other → preset bank → edit,no,The text edit tool must be saved (ctrl+s).,Use this to manually edit the bank list.,,:A -open,:A -clear,:ba ' :x = 1 3 5 || :x 2 4 ' :v 0 :pr 2
:A,-clear,,,,bank,n/a,clear the bank,other → preset bank → clear,no,This cant be undone!,Use this to clear the bank list.,,:A -open,:A -clear,:ba ' :x = 1 3 5 || :x 2 4 ' :v 0 :pr 2
:B,,,%,% = float = value,time,0.5,set the units for positional timing mode,timing → position options → resolution,no,This setting only effects positional timing (:E 2). It determines the resolution at which the cycle time will change as you drag it across the screen.,Set the interval to whatever (positive) value you want. Ie. 0.5 will allow for half second intervals‚ 2 for 2 second intervals‚ etc.,Enter edit mode (Ctrl+E) and drag this context around the canvas‚ watching what happens to the cycle time (top left atom). Then change the positional resolution (:B) and try again. (Note that the origin point of this canvas is the top left corner.),:B 0.1,:B 2,:E 2 :v 0 :X 9 :Z 15 :pr 2
:C,,,%,% = float = value,time,20,determine how fast the timing alters in positional timing,timing → position options → scale,no,This setting only effects positional timing (:E 2). It determines the how fast the cycle time will change as you drag it across the screen.,Use high numbers for a lot of change and low numbers for less change. Note that the 0 point is ether the origin of the canvas or the context with n-1 ID number (if this one also has :E 2 on).,Enter edit mode (Ctrl+E) and drag this context around the canvas‚ watching what happens to the cycle time (top left atom). Then change the positional resolution (:B) and try again. (Note that the origin point of this canvas is the top left corner.),:C 5,:C 60,:E 2 :v 0 :X 9 :Z 15 :pr 2
:D,,,%,% = float = value (positive),time,1,set the units for random timing mode,timing → random options → resolution,no,This setting only effects random timing (:E 1). It determines the allowed intervals at which random timings are allowed.,Set the interval to whatever (positive) value you want. Ie. 0.5 will allow for half second intervals‚ 2 for 2 second intervals‚ etc. Use long decimals for fractions ie. 0.3333333 for 1/3.,Select the different units and see what it does to the time intervals (top left atom). Note that :q (minimum) is set to 1 here‚ otherwise the series would start at 0.,:D .3333333,:D 2,:E 1 :v 0 :d 4 :x 5 :i 5 1.5 :s :q 1 :pr 2
:E,,random position off,%,% = float (0‚ 1‚ 2) or symbol (see alias),time,0,determine how context cycle times are set,timing → delay mode,no,0 is normal mode: timings are set by the :d value or the atom in the top left corner of the GUI. 1 is random mode: timings are random‚ with :d being the maxumim (see the :D‚ :q and :Q settings). 2 is positional mode: the time is set by the contexts position on the canvas‚ with :d having no effect (see the :B and :C settings).,Use this to switch between different timing modes.,In random mode (:E 1)‚ start (double click) on context to see how the time changes. In positonal mode (:E 2)‚ move the context around the screen to see the time change. (You will have to be in PDs edit mode to do this—press Ctrl+e).,:E 1,:E 2,:d 4 :pr 2
:F,,,%,% = float = value,general,0,set x-axis zoom,no,shift + double click and drag over the right-hand margin,The units are measured in pixles past the default size (which is 12 pixels per togle). It doesnt update very fast‚ so it is best not to send a continuous stream of :F values.,This is useful to improve the readability when toggle floats are on. It is also used when context is embedded.,,:F 20,:F -10,:x 1 2 3 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:G,,,%,% = float = value,general,1,set y-axis zoom,no,shift + double click and drag over the bottom margin,The units are measured in pixles past the default size (which is 12 pixels per togle). It doesnt update very fast‚ so it is best not to send a continuous stream of :G values.,This is useful to improve the readability when toggle floats are on. It is also used when context is embedded.,,:G 20,:G -10,:y 1 2 3 4 :i 1 2 3 4 :v 0 :pr 2
:H,,,%,% = float > 1,saving,0,identify where the overlay instructions start within the saving list,no,no,:H must come at the beginning of the saving list‚ if at all., :H takes care of itself and is best not tampered with.,No example given.,,,:v 0
:I,,,%,% = float = state (0‚ 1),input,0,turn rules on or off,other → rules → on-off,no,The rule list is a user defined list rules determining what context should go given certain in/output. The rule is is stored in the :ex command but turned on or off with :I. If it is turned on (:I 1)‚ all context input is compared against each item on the list. If it matches‚ the condition (also specified in the rule list) will follow. If not‚ it will continue as normal. Note that it is best to keep this function off if you are not using it‚ since it slows things down a bit.,Rules are used to establish logical behavior that cannot be defined by the normal connections of a network. See manual Section 15: Rules and helpfiles → 14_rules.pd,Here‚ the rule list contains the text 'start 2'. Turn rules on (:I) and the message 'start 2' will be rejected ('start 1' would still pass normally). Turning the rule list off (:I) means that all messages will be accepted as normal.,:I,start 2,:v 0 :d 2 :x = 4 3 2 1 :I 1 :ex ' 1 :s equals 2 || c- '
:I,-save,,,,input,n/a,save rule list,other → rules → save,no,This saves the rule list to the Context creation argument so that it will be loaded next time the patch is opened. Note that this is different from Ctrl+S from within the rule list edit window‚ which you need to press in order to load the rules.,,,:I -save,:I -open,:v 0 :d 2 :x = 4 3 2 1 :I 1 :ex ' 1 :s equals 2 || c- '
:I,-open,-edit,,,input,n/a,open a text dialogue to manually edit the rule list,other → rules → edit list,no,Use this to manually edit the rule list (separating entries with semi-colons). Remember to press Ctrl + S afterwards to load the rules.,,,:I -save,:I -open,:v 0 :d 2 :x = 4 3 2 1 :I 1 :ex ' 1 :s equals 2 || c- '
:I,-clear,,,,input,n/a,clear the rule list,other → rules → clear,no,This cant be undone!,,,:I -clear,:I -open,:v 0 :d 2 :x = 4 3 2 1 :I 1 :ex ' 1 :s equals 2 || c- '
:J,,,%,% = float = state (0‚ 1‚ 2) or symbol,general,0,toggle-float send domain,other → more → miscellaneous → float send,no,When :J 0‚ float-connections will only be received by a context open in the same patch. This means that two patches which share the same context ID numbers will not communicate with each other if they are both open at the same time. When :J 1‚ float-connect will communicate with any context open in any patch. When :J 2‚ float-connect will communicate only with Contexts embedded within this one. This is useful if for using Context as a sort of sample database. When :J is set to a symbol‚ float-connect will communicate with a custom patch. The custom patch is defined by the “patch” object. So if ' :J me ' is set‚ then float-connections will only communicate with the patch which has the object [patch me] open in it.,Use this to safeguard against accidental interference between different conttext networks.,With :J 1 on‚ the context toggle-float will start another context number 2 in another patch‚ if such a context exists.,:J,,:v 0 :x 1 5 :i 2.5 0 0 0 1.5 :d 1 :s :pr 2
:K,,* / off ^ map none,%,% = float (0‚ 1‚ 2‚ 3‚ 4) or symbol (see alias),time,0,set coefficient mode,timing → calculation → calculation mode,no,This sets how the coefficient (:k) value affects the cycle time. With :K 1 the :d value (top-left atom) is multiplied into the :k value. With :K 2‚ the atom is divided by the :k value (:k/:d). With :K 3‚ the :K value is taken to the :d-th power (:k^:d). With :K 4‚  custom map may be established (enter a list of numbers for :k) such that :d1 = :k1‚ :d2 = :k2‚ etc. With :K 0 (default) the :k value is ignored.,:K 1 allows you to create you own time units‚ ie. minutes (:k 60) instead of seconds. :K 2 means that the time atom (top left) determines inverse time values‚ ie. 2 for half a second‚ 3 for a third of a second‚ etc. (assuming that :k is set to 1). This is very useful for musical notation!,Here‚ :k is set to 2 and :d to 3. With :K 1‚ the cycle time will be 2 * 3 = 6 seconds. With :K 2 the time will be 2/3 of a second.,:K 1,:K 2,:v 0 :x 5 :i 5 1.5 :d 3 :s :k 2 :pr 2
:L,,all random linear,%,% = float (0‚ 1‚ 2) or symbol (see alias),burst,0,select from three common burst settings,burst → presets,no,This burst has a near infinite arrange of settings‚ but the three extremes which are most useful are ALL‚ RANDOM and LINEAR. ALL means that all open burst toggles will be fired at the end of every cycle. RANDOM means that a single random toggle will fire‚ with even distribution. LINEAR means that the toggles will fire one by one sequentially.,This is just a convenient way of navigating the otherwise dense set of burst controls.,The burst is set to ALL by default. You can choose RANDOM and LINEAR here to see the difference.,:L random,:L linear,:v 0 :y 1 2 3 4 :i 5 1.5 :d .7 :s :L all :pr 2
:M,,,%,% = float = state (0‚ 1),general,0,switch x and y axes,no,shift and double click over the time atom (top left),Note that the toggle‚ toggle-float and database arrangements are all flipped‚ just as you would expect.,Since PD does not allow for outlets on the side of an object‚ the burst toggles can be difficult to access. The solution is to flip the axes‚ so that the burst is along the bottom.,,:M,,:v 0 :a ' x1 | x2 | x3 | x4 ' :b ' y1 | y2 | y3 | y4 ' :x 1 2 3 4 :y 1 2 3 4 :i 5 1.5 :d 2 :s :e 4 :f 4 :pr 2
:N,,hold,%,% = float = value,input,n/a,queue the next context command,no,no,:N allows you to delay the effect of another context command. The float value determines how long you want to delay it. Each time any input is received‚ the command will move one place higher on the list. Without any further arguments‚ :N will hold the next command that the context receives. One context can have any number of queued commands. ,Delaying commands is especially useful for toggles. Cue a toggle to be switched in three bars time and then wait.,Press ':N 3' followed by 'stop' and you will queue the stop message for three cycles. Make sure you press 'stop' before the end of the next cycle‚ otherwise you will queue the next 'start' message‚ not the stop!,:N 3,stop,:v 0 :x 5 :i 5 1.5 :d 2 :s :pr 2
:N,,hold,%1 %2...,%1 = value‚ %2 = context command letter,input,n/a,queue specified context command,no,no,:N allows you to delay the effect of another context command. The float value determines how long you want to delay it. Each time any input is received‚ the command will move one place higher on the list. One context can have any number of queued commands.,Delaying commands is especially useful for toggles. Cue a toggle to be switched in three bars time and then wait.,Everything after the :N x message will be delayed by x commands. A 'command' is any input that context receives‚ including automatic start messages. So the effect is that the message is delayed by x cycles. The :N 2 appears to be delayed by only one cycle‚ but this is because the subsequent message is compound of two commands‚ :d and :s‚ each of which counts as one. Note that setups like this work better with safety off (:z 0)‚ since otherwise the input will be closed for 10ms each cycle‚ preventig some of the desired messages from getting through.,:N 3 :x 3,:N 2 :d * -1,:v 0 :x 1 4 5 :i 5 1.5 :rd 1 :d 2 :s :z 0 :pr 2
:N,,hold,%1 %2 {%3...},%1 = value‚ %2 = symbol‚ %3 = command,input,n/a,queue a context command with conditional return,no,no,Usually‚ held commands are pushed up the queue by any (recognized) context input. The second argument to :N locks the command to one input. So ':N 3 y' means that the following command will only be advanced by the :y command‚ ie. the third :y command that is received will trigger the held command. Note that the second argument does not take a colon ('x' instead of ':x').,Use this to define conditional changes to a context.,Once you press the :N message‚ it queues the :x command‚ which will only respond to the :y command. The result is that the :x toggle will be triggered on the third :y input.,:N 3 y :x 2,:y 1,:v 0 :x 5 :i 5 1.5 :d 2 :s :pr 2
:N,-p,hold,%1 %2 {%3...},%1 = value‚ %2 = symbol‚ %3 = command,input,n/a,suspend a context command,no,no,The -p switch queues a command‚ but also prevents other commands with the same operator being accepted until it has cleared the queue. Note that the start (':s') and stop (':st') commands are suspended by default‚ as this is the most useful behaviour for them.,Use this to force a Context to be off for a certain amount of time‚ even when it is receiving 'start' commands.,In the first example‚ sending ':N 3 s' will mean that Context cancels the next 3 start messages that it receives. Double click on Context to start it‚ and only the fourth one will work. In the second example‚ Context refuses to take any :x input once the message is sent. When it gives way on the fourth round‚ a new ':x 4' message is also sent.,:N -p 3 x :x 4,:N 3 s,:v 0 :d 1
:NN,,,%,% = any,input,n/a,custom advance for conditional queue return,no,no,The :NN command is used with the :N command. It can be used to advance a queued message without triggering the a command in the process.,You can use this command to advance :N messages with arbitrary arguments‚ ie. ':N 2' foo :x 2 and ':NN foo'.,Here‚ the queued message will only be advanced with a :y message. But you can forward it without triggering a y-axis toggle by using ':NN y.',:N 3 y :x 2,:NN y,:v 0 :x 5 :i 5 1.5 :d 2 :s :pr 2
:O,,shuffle,%,% = float = percentage (+ve or -ve),time,0,shuffle for pattern bank,timing → more → shuffle,no,This adds a shuffle to the timing of the pattern‚ affecting even numbered beats. Positive numbers push them forward‚ while negative numbers bring them back. Note that shuffling a Context with an odd number of toggles on the pattern axis will distort the cycle. For this reason‚ its best to stick to even numbered Contexts when using Shuffle.,Use this to enhance a rhythm stored in the pattern bank.,Look at the gaps between the beats when shuffle is on.,:O 60,:O -60,:v 0 :x 1 2 3 4 5 :i 5 1 :d 2 :s :pr 2
:P,,,%,% = float = value,burst,0,define an arithmetic progression for the burst selection,burst → selection → progression,no,This determines an arithmetic progression on the selection of the burst toggle(s) each cycle. Positive and negative numbers are accepted. Note that non-integer numbers have a special effect on the :R setting.,Use this to make a linear progression from one toggle to the next.,Look at which toggles are firing each cycle.,:P 1,:P 2,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :o 2 4 :d 1 :s :v 0 :pr 2
:Q,,,%,% = float = state (0‚ 1),time,1,determine whether random timing auto-advances after every cycle,timing → random options → auto advance,no,This setting works in conjunction with random timing (:E 1). When on (default)‚ a new cycle time is randomly selected after each cycle. When off‚ context waits to receive a 'bump d' message to advance the timing.,Use this if you want to hold random timings for more than one cycle.,With :Q off‚ new cycle timings will not be selected‚ until context receives a 'bang d'.,:Q,bump d,:v 0 :x 5 :i 5 1.5 :d 3 :q 1 :E 1 :s :pr 2
:R,,,%,% = float = percentage,burst,0,randomize the burst toggle selection,burst → selection → random,no,This setting works as a percentage. 0 means that the burst toggle selection is definitive and 100 means that it is totally random. Numbers in between describe varying degrees on uncertainty‚ so that the burst quantity will deviate from :o with :R likelihood‚ according to Gaussian distribution. 101 gives even distribution through an 'urn' generator‚ meaning that all available numbers will be used once before the urn is reset‚ like pulling numbers out of a bag. The urn can be reset manually using the 'bump l' command. Note that if :P is set to a non-integer‚ the random mean position will not reset each cycle‚ meaning that the random deviations will center around the same point.,Use this setting to add uncertainty in a context network.,,:R 100,:R 2,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1 :d .7 :s :o 1 3 5 :v 0 :pr 2
:R,-open,,,,burst,n/a,edit random distribution array,burst → selection → edit random,no,This command opens the array which defines the probabilities for the :l setting. Normally you will see a Bell curve here (if :l is greater that 0 and less than 100)‚ but you can draw in a curve to define a new range of probabilities. Unfortunately‚ any changes you make here are unsavable.,Use this to define custom probabilities for the burst selection.,Open the array and draw in your own curve. You will see the changes reflected in the selection of burst toggles that fire.,:R -open,:R 20,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 2 :s :v 0 :pr 2 :R 30
:S,,,%,% = any,database,blank,prepend custom text to the x-axis database,message → x-axis → prepend,no,This prepends any custom text to the beginning of every message sent from the bank database.,This can help to simplify and organize database storage. It is also useful if you want to is the [ or [o message variables to direct the context outlet.,Look at the text that appears in the symbol atom vs. the text that prints in the console to undestand the effect of :S.,:S carrot,:S tomato,:X 9 :d 4 :v 0 :a ' 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 ' :e 8 :x 1 2 3 4 5 6 7 8 9 :i 9 1.5 :s :pr 2
:T,,,%,% = any,database,blank,append custom text to the x-axis database,message → x-axis → append,no,This append any custom text to the end of every message sent from the bank database.,This can help to simplify and organize database storage.,Look at the text that appears in the symbol atom vs. the text that prints in the console to undestand the effect of :T.,:T brocolli,:T cabbage,:X 9 :d 4 :v 0 :a ' 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 ' :e 8 :x 1 2 3 4 5 6 7 8 9 :i 9 1.5 :s :pr 2
:U,,,%,% = any,database,blank,prepend custom text to the y-axis database,message → y-axis → prepend,no,This prepends any custom text to the beginning of every message sent from the bank database.,This can help to simplify and organize database storage. It is also useful if you want to is the [ or [o message variables to direct the context outlet.,Look at the text that appears in the symbol atom vs. the text that prints in the console to undestand the effect of :S.,:U carrot,:U tomato,:d 3 :v 0 :b ' 1 | 2 | 3 | 4 ' :f 4 :y 1 2 3 4 :i 5 1.5 :M 1 :s :pr 2
:V,,,%,% = any,database,blank,append custom text to the y-axis database,message → y-axis → append,no,This append any custom text to the end of every message sent from the bank database.,This can help to simplify and organize database storage.,Look at the text that appears in the symbol atom vs. the text that prints in the console to undestand the effect of :T.,:V brocolli,:V cabbage,:d 3 :v 0 :b ' 1 | 2 | 3 | 4 ' :f 4 :y 1 2 3 4 :i 5 1.5 :M 1 :s :pr 2
:W,,,%,% = float = state (0‚ 1),burst,0,determine whether random burst selections can wrap,burst → selection → wrap,no,,When there is a small amount of random deviation to the number of burst toggles (ie. :R 10)‚ the number will follow a 'drunken' walk pattern. The :W setting determines whether it hits a 'wall' at the end or whether it wraps back around‚ ie. If the toggles can randomly go from the top to the bottom of the toggle array.,With :W off you will probably see the selected toggle hitting a wall an staying there‚ whereas with :W on it will wrap around to the other edge.,:W 1,:W 0,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :R 10 :d .1 :s :v 0 :pr 2
:X,,,%,% = float = number of toggles,general,5,set x-axis length,no,shift + click and drag over the right-hand margin,This causes audio drop-outs.,Dragging the GUI is much more accessible‚ but this command may be useful for resizing large groups of contexts.,,:X 2,:X 9,:v 0
:Y,,,%,% = float = number of toggles,general,4,set y-axis height,no,shift + click and drag over the bottom margin,This causes audio drop-outs.,Dragging the GUI is much more accessible‚ but this command may be useful for resizing large groups of contexts.,,:Y 1,:Y 7,:v 0
:Z,,,%,% = float = value,general,7,set the size of the input atoms,no,shift + click and drag over the atoms right edge,:Z 0 hides the atoms completely.,This is for convenience and has no other effect.,,:Z 32,:Z 0,:: long :v 0
:ba,,,list,semi-colon separated,input,blank,store the bank settings,other → bank → edit,no,Note that you cant type semi-colons within PD‚ so these lists are difficult to edit.,Bank list saving generally takes care of itself and so this command is best left untouched.,No example given.,,,:v 0
:bs,,,%,% = float = state (0‚ 1),burst,0,determine burst behaviour,burst → more → burst mode,no,When :bs is set to 0 (default)‚ the burst will fire at the end of the cycle. This is the normal behaviour of Context. When :bs is set to 1‚ the burst fires every time the pattern fires‚ but not at the end of the cycle. ,Use :bs 1 if you want to create a pattern which utilizes some of the features of the burst (ie. random selection)‚ but dont mind giving up the firing at the end of cycle.,Turn :bs on and off and watch how the burst functions differenty.,:bs,start,:v 0 :x 1 3 :d 3 :y 1 2 3 :bs 1 :L all
:es,,,%,% = float = state (0‚ 1),overlay,0,determine whether embedded contexts come to a hard stop,other → more → overlay → embed stop,no,When one context is embedded inside another (ie. created in the overlay)‚ it will turn and stay on while the parent contexts cursor hovers over it. This setting determines how the context stops. :es 0 brings the embedded context to a hard stop when the cursor passes‚ whereas :es 1 lets it come to the end of its cycle.,Use this to determine the behaviour of embeded contexts,No example given.,,,:v 0
:ex,,,list,semi-colon separated,input,blank,store the rule list,other → rule → edit,no,Use the | symbol as a separator if typing the list in by hand in PD.,Rule list saving generally takes care of itself and so this command is best left untouched.,No example given.,,,:v 0
:ID,,:id,%,% = float = value,ID,blank,assign an ID number to context,ID → ID number,no,Each context has one unique ID number which is used for sending and receiving messages. If the ID number is 6‚ context will receive messages through the 'c6' and send them to the 'c6-' channel.,ID numbers generally take care of themselves and are best left untampered with‚ but can be manually controled using the :ID command.,Look for the ID number on the context canvas.,:id 2,:id 4,:v 0
:ID,-reset,:id,,,ID,n/a,reset ID number,no,no,This resets the ID number and loads it to the lowest available number that is not occupied by another Context.,Use this if your ID numbers have gotten out of order because of deleting and creating too many Contexts.,,:id 2,:id -reset,:v 0
:ID,-f,:id,%,% = float = value,ID,n/a,reset ID number followed by toggle-float connections,no,no,This sets a new ID number‚ but in addition asks any toggle float connection which is linked to this Context to update to the new ID number.,Use this if you want to set a new ID number but not lose the toggle float connections leading to this Context.,Watch the ID number and toggle float change at the same time. (Any other Context open in the same patch with the same toggle-float would also change).,:id -f 2,:id -f 1,:v 0 :i 5 c1 :x 5
:il,,,%,% = float = state (0‚ 1‚ 2),general,0,display information about the Context state,other → state → input label,no,:il 1 briefly displays every change made to the Context state. :il 2 permanently displays the entire Context state. :il 0 turns off the display.,The label is useful for understanding Context commands and for debugging.,Turn on :il 1 or :il 2 and click toggles to see what happens to the display.,:il 1,:il 2,:v 0 :il 1 :a some message
:io,,,%,,overlay,blank,overlay inlets~ and outlets~,,create objects on the overlay ???,,,,,,:v 0
:ol,,,%,% = float = state (0‚ 1),overlay,0,optimize context for embedding,other → more → overlay →embedded,no,Contexts behaviour changes slightly when an object is embedded in it: 1. Its DSP is switched on (for embedded contexts). 2. The overlay patch is saved in the creation argument. 3. Context resizing (:X and :Y) changes slightly to account for embedded objects. This setting generally takes care of itself and it is best to leave it untouched. However‚ you can use this to switch back to regular mode. (Context resizing is more clunky with :ol 1‚ which is one reason you might want to switch back).,Turn :ol off if you have embeded objects in the overlay patch but outside of the GOP area to improve context resizing.,No example given.,,,:v 0
:ol,-save,,,,overlay,n/a,save overlay,other → more → overlay → save overlay,no,This saves the overlay patch to contexts creation argument‚ but you need to save the main patch again (ctrl+s) to save it to file.,,,:oI -save,:oI -open,:v 0
:ol,-open,-edit,,,overlay,n/a,open the overlay,other → more → overlay → view overlay,right click + open,,,,:oI -save,:oI -open,:v 0
:ol,-clear,,,,overlay,n/a,clear the overlay,other → more → overlay → clear overlay,no,This clears the overlay from the creation argument‚ but does not affect the overlay patch. Re-saving the patch will undo the clear.,,No example given.,,,:v 0
:pr,,print,%,% = float = state (0‚ 1‚ 2),general,0,print context output and state,other → state → auto print,no,1 prints all output messages to the console as they are sequenced. 2 prints this as well as any command input.,This is useful for designing and debubbing.,With :pr 1‚ this example will print “my message”‚ which is the message stored in :a. With :pr 2‚ it will also print :s‚ because Context is being restarted by the toggle-float at the end.,:pr 1,:pr 2,:v 0 :x 2 5 :i 5 1.5 :d 1 :s :a my message
:pr,,print,{%1},% = command letter (or 'overlay'),saving,n/a,print context settings to the console,other → state → print state,no,This prints the contexts current state to the console. The first term of the printed message is the contexts ID number.,Use this to examine or copy a contexts state. A simple 'print' message with no argument will fetch the entire state‚ while individual command characters (without the colon) will fetch specific states (ie. 'print d a' to see the :d and :a settings). 'print -overlay' prints the entire context state plus the overlay patch. ,,print overlay,print d a,:v 0 :d 3 :a this is my message :pr 2
:rd,,,%,% = float = state (0‚ 1),operation,0,switch first and last toggle for reverse playback,other → more → cycle reversal → reverse last,no,This setting addresses a specific problem. The last toggle is often used to loop a context‚ as in the example‚ but the logic of this is broken if the context cycle is reversed (ie. if :d is negative). :rd reverses the order of the first and last toggle so that loops can remain intact. The reversal only comes into effect when the cycle is negative.,Use this if you want to be able to reverse a context that is auto-looped.,' :d * -1 :s ' reverses the context cycle and ' :rd ' turns this setting on and off. Explore the four different combinations and you will see that the loop fails if the cycle is reversed and :rd is off.,:d * -1 :s,:rd,:v 0 :x 1 2 4 5 :i 5 1.5 :d 2 :rd 1 :s :pr 2
:rt,,,%,% = float = state (0‚ 1),operation,0,shift toggle alignment in reverse playback.,other → more → cycle reversal → offset pattern,no,This setting addresses a specific problem. When Context has its cycle time reversed‚ the Pattern will usually play back in reverse‚ with the last toggle going at the very beginning and the first toggle going at the very end. This makes sense logically‚ but not musically. If we want to play a pattern 'A B C D in reverse‚ we want the 'A to come ¾ of the way through the bar‚ not at the end of it. The :rt setting corrects this problem by shifting the alignment of the internal counter with the toggle array‚ so that in reverse‚ the last beat of the bar (the second last toggle) comes first‚ the second-last beat of the bar comes second‚ etc. A side effect of this is that there is no toggle toggle left to play at the very end of the cyce—unless you are using :rt in conjunction with :rd.,Use :rt if you want to play a melody in reverse‚ with the (old) first beat of the bar playing on the (new) last beat. Use in conjunction with :rd if you want the Context to be able to repeat‚ ie. bounce back on itself.,Notice how the Context pattern is playing (ie. watch the printing messages). With :rt on‚ the pattern is 'A-B-C-D-D-B-C-A-.... With :rt off‚ it is 'A-B-C-D-BLANK-D-C-B-....,:rt 1,:rt 0,:v 0 :d 2 :rt 1 :rd 1 :b ' | | | . :d * -1 :s ' :pr 1 :a a | b | c | d :x 1 2 3 4 5 :e 5 :s
:rm,,,%,% = float = state (0‚ 1),messages,1,determine whether random variable (?) auto-advances after every cycle,messages → variables → ? auto advance,no,This setting determines whether the ? message variable selects a new random value every time it fires.,Note that you can advance the ? variable at any time using the 'bump m' message.,The database contains the text '? 10'‚ so Context will send a random number between 0 and 9 each time it fires. If :rm is off‚ the random number will persist until :rm is switched on again‚ or it receives a “bump m” message.,:rm,bump m,:v 0 :a ' ?10 ' :x 1 2 3 4 5 :i 5 1.5 :d 2
:ro,,,%,% = float = value,messages,0,create an offset for the ? variable,messages → variables → ? offset,no,This adds a single digit to the random values which are selected by the ? variable.,The basic purpose of this setting is to ensure that there are no zeros in random arrays‚ so that they can generate meaningful data for setting toggles. Beyond this‚ it is also possible to add decimal places‚ or random numbers which might be below 0.,,:ro 1,:ro 10,:v 0 :a ' ?10 ' :x 1 2 3 4 5 :i 5 1.5 :d 2 :pr 2
:nr,,,%,% = float = state (0‚ 1),messages,0,determine whethther the ID variable (^) selects randomly or sequentially,messages → variables → ^ random,no,The ^ message variable returns an ID number in place of a tag (argument). This setting determines whether the ID number is chosen randomly or sequentially.,Use this when using one Context to control a group of other Contexts.,No example given.,,,:v 0
:se,,,%,% = float = state (0‚ 1‚ 2),general,0,determine where the context menu commands are sent,other → send settings to,no,This command makes the context menu affect more than one context. :se 1 allows you to send settings to all contexts‚ effectively turning the selected one into a global menu. :se 2 sends the setting selections only to the contexts outlets. The default :se 0 means that only the given context will be affected by the menu selection. Creating a global menu can get confusing‚ but it is always possible to bypass the :se setting by pressing Ctrl.,,No example given.,,,:v 0
:se,,,%,% = symbol,general,blank,send the context menu commands to  custom channel,other → send settings to,no,This selects a custom send channel for the contexts menu selection. Ie. ' :se guitar ' will send the settings to any contexts with the tag 'guitar'.,,No example given.,,,:v 0
:te,,tempo,%,% = float = value,time,100,mutliply the cycle time,timing → calculation → tempo,no,This multiplies the cycle time by a given percenage to allow for global tempo changes.,The :te setting is no different than the :K 1 setting—it is simply a multiplier for the cycle time. Why does it exist? So that you can change the tempo of a group of Contexts even while some of them still have independent :k values.,The :te value would only stand out as useful if you wanted to change the global tempo of a set of Contexts‚ some of which were using :k and :K for other purposes.,:te 75,:te 115,:v 0 :x 1 2 3 4 5 :i 5 1.5 :d 2 :s :pr 2 :s
:x1,:x2 :y1 :y2,,%,% = float = seconds,overlay,0,determine contexts position on a parent canvas,no,use [move] abstraction,:x1 = x start point‚ :x2 = x end point‚ :y1 = y start point‚ :y2 = y end point.,These commands only come into effect when context is embedded in a timeline. They generally take care of themselves and are best left alone.,No example given.,,,:v 0
:ln,{-},,%,% = symbol,operation,blank,set a custom receive channel,ID → receive,no,This creates a custom recieve channel which can be used to send messages to Context. This can also be done with tags (:n)‚ but :ln has a few differences. 1: Only one :ln channel can exist‚ and it has no send component. 2: It can be set dynamically without creating audio dropouts. 3: An optional '-' argument at the beginning means that Context will start every time it receives input through that channel.,Use this to link two Contexts together‚ so that the output of one is automatically received by the other without having to connect them. If using ID numbers‚ make sure not to forget the dash (ie. 'c2-').,This example wont demonstrate very much unless you create another Context with ID number 2.,:ln c2-,:ln - c2-,:v 0 :d 1
:ms,,,%,% = float = state (0‚ 1),messages,0,prepend dollar-zero value to send prefix <,messages → variables → < prepend,no,This setting affects the < message variable which is used to send a message to a specific location. Usually‚ the < variable determines that the message will be sent to the first argument (ie. message '< you me' would send message 'me' to [receive you]. :ms 1 prepends a %0 value to the send channel. Ie. if :ms is on‚ message '< you me would send message 'me to [receive %0-you]. The %0 value is that of the parent patch in which Context is created.,Use this if you want to send a message to an object in the parent patch only.,This example wont demonstrate very much unless you create receive objects [receive me] and [receive %0-me].,:ms 0,:ms 1,:v 0 :x 1 :a ' < me here is my message '
:pu,,,%,% = float = state (0‚ 1),burst,0,turns on structured hierarchy mode for 'push' messages,burst → more → structure mode,no,This setting allows Context to receive 'push messages used for creating structured hierarchies. See the entry on 'push' to understand what this does.,Use the load preset [context :: structure] to make use of this mode,There is not much to see here. Go to helpfiles→structure.pd for an example of a structured hierarchy.,:pu 1,:pu 0,:v 0
:sw,,,%,% = float = state (0‚ 1),overlay,0,turns the internal [switch~] permanently on,other → more → miscellaneous  → switch,no,There is a [switch~] object inside every Context which usually inhibits DSP processing. It is automatically switched on when Content arrays or other embedded objects play‚ but is usually kept off while Context is idle‚ for efficiency. This setting turns [switch~] on permanently‚ in case this is useful.,Use this if you want are embedding audio objects inside Context and want them to work when Context is idle.,This example wont demonstrate very much.,:sw 1,:sw 0,:v 0
:sx,,,%,% = float = state (0‚ 1),toggles,0,force only one toggle on the x-axis,other → more → toggles → force x,no,This setting allows you to set that only one toggle will ever be on in the x-axis‚ a bit like a PD 'radio' object. If it is off then any toggles can be open.,Use this if you want to use the x-axis as a selector.,Turn :sx on and then click on toggles on the x-axis.,:sx,:sy,:v 0 :x 1 2 3 :pr 2
:sy,,,%,% = float = state (0‚ 1),toggles,0,force only one toggle on the y-axis,other → more → toggles → force y,no,This setting allows you to set that only one toggle will ever be on in the y-axis‚ a bit like a PD 'radio' object. If it is off then any toggles can be open.,Use this if you want to use the y-axis as a selector.,Turn :sy on and then click on toggles on the y-axis.,:sy,:sy,:v 0 :y 1 2 :pr 2
:le,,,%,% = float = state (0‚ 1),operation,0,force = to misread the first toggle when interrupted,other → more → toggles → legacy,no,When this setting is on‚ the = message variable will misread the first toggle when it is interrupted in its cycle. Instead of the correct value‚ the next position from where the cycle was interrupted is reported.,This bug can have unexpected musical effect‚ so it is maintained here.,You need to interrupt the Context cycle in order to notice the difference‚ ie. start it while it is already in cycle.,:le 1,:le 0,:v 0 :x 1 2 3 4 5 :i 1 2 3 4 5 :a = :pr 2 :d 4
:ze,,,%,% = any,time,bang,trigger message event on time safety reset.,timing → other → safety trigger,no,The :z 1 function prevents Context from starting twice in a period of 25ms. This is to protect against infinite regressions‚ which would otherwise eat up CPU. When a Context does try to start twice within the threshold amount‚ an event is triggered‚ which is defined by the :ze setting. This event will be sent to the regular send channels and could contain any message. Prepending the message with ' . ' will send a message back to the same Context.,This is primarily useful for reseting the cycle time to a larger value‚ as in the example.,Start Context and you will see that it loops and halves its cycle time each lap. When the time reaches less than 25m‚ the safety feature cuts the loop‚ and the :ze function resets the time t 1. Without this‚ you would have to reset it manually. Note that ' quotation marks ' are necessary in the :ze message‚ so that :d is not interpreted on the way in.,:ze ' . :d 1 ',:ze bang,:v 0 :y 1 4 :d 1 :b ' . :d * .5 ' :j 4 c1 :ze ' . :d 1 '
bump,,,,,burst,n/a,advance the burst selection,no,no,This selects a new set of burst toggles‚ according to the burst settigs.,Use this in conjunction with burst auto-advance (:m 0).,While :m 0 is set‚ the toggle selection wont advance unless the context receives a 'bump' message. When :m 1 is set‚ toggle selection advances each burst cycle.,bump,:m,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 1 :m 0 :P 1 :s :v 0 :pr 2
bump,d,,,,time,n/a,advance the random timing,no,no,This selects a new random cycle time.,Use this in conjunction with random timing (:E 1) and random advance (:ra 0).,:E 1 is on‚ but with :ra off‚ new cycle timings will not be selected until context receives a 'bang d'.,:ra,bump d,:v 0 :x 5 :i 5 1.5 :d 3 :q 1 :E 1 :ra 0 :s :pr 2
bump,m,,,,general,n/a,advance the random message variable (?),no,no,This advances the random message variable for output messages.,Use this to select a new random value if :rm is off.,The database contains the text '? 10'‚ so Context will send a random number between 0 and 9 each time it fires. If :rm is off‚ the random number will persist until :rm is switched on again‚ or it receives a “bump m” message.,:rm,bump m,:v 0 :a ' ?10 ' :x 1 2 3 4 5 :i 5 1.5 :d 2
bump,l,,,,burst,n/a,reset the burst quantity urn,no,no,If :l is set to 101‚ the burst quantity will be determined by an urn (that is‚ each number will be selected once at random‚ like taking numbers out of a bag‚ before being reset). “bump l” resets the urn‚ putting all the numbers back in the bag.,:l 101 is useful if you want every open toggle to be randomly selected once in a sequence. Use “bump l” to establish the beginning of the sequence.,Look at how many toggles fire each cycle to understand lR 101. The sequence will come in groups of 4. “bump l” will define the beginning of the group.,bump l,,:M 1 :x 1 2 3 4 5 :i 5 1.5 :d 1 start :v 0 :l 101
bump,R,,,,burst,n/a,reset the burst selection urn,no,no,If :R is set to 101‚ the burst quantity will be determined by an urn (that is‚ each number will be selected once at random‚ like taking numbers out of a bag‚ before being reset). “bump R” resets the urn‚ putting all the numbers back in the bag.,:R 101 is useful if you want every open toggle to be randomly selected once in a sequence. Use “bump R” to establish the beginning of the sequence.,Look at which toggles fire each cycle to understand :R 101. The sequence will come in groups of 4. “bump R” will define the beginning of the group.,bump R,,:M 1 :x 1 2 3 4 5 :i 5 1.5 :d 1 start :v 0 :R 101
push,,,%,% = float = ID number (automatically supplied),burst,n/a,call the next term of a structured hierarchy,no,no,'push' is a command used to call the next state of a structured hierarchy. It is an alternative to the regular Context cycle designed to allow for adding structure to Context networks. 'push' will only work in a Context which has setting :pu 1 (which essentially marks this Context as a structural array. Once a series of :pu 1 contexts have been linked together with toggle float connections‚ the 'push action works as follows: 1: send a 'push' command to the Context connected to the selected burst toggle (which then 2: sends another 'push' command‚ etc.). 3: When the end of the chain is reached‚ cycle that Context. 4: At the end of the cycle‚ 'bump' the burst‚ then send a prompt to the preceeding Context. 5: If the preceeding Context is at the end of its Burst array‚ send a prompt to the preceeding Context‚ etc.,'push' only works with setting :pu 1. In addition‚ it works best with :m 0 (auto-advance off). This is all wrapped up in an easy to use load preset [context :: structure].,There is not much to see here. Go to helpfiles→structure.pd for an example of a structured hierarchy.,push,:pu 1,:v 0 :pu 1
-route,,,%,% = anything,messages,n/a,pass a message through this Context,no,no,'-route' is used to pass a custom message through a Context. It doesnt affect the Context it is send to in any way. If Context receives a message “ -route :d 4”‚ it immediately sends a message “:d 4” to all of its outlets.,'-route' is useful if you want to use one Context to relay messages to others. Note that it will send to the Burst toggles‚ so you should probably use :M 1.,There wont be much visible in this example‚ unless you link this Context up to another one.,-route ' :d 5 ',-route ' :c 3 ',:v 0 :M 1
fetch,,,%1 %2,%1 = symbol = channel‚ %2 = symbol = command letter,general,n/a,fetch a context setting and send it to a specified location,no,no,Like print‚ 'fetch' helps you retrieve something from the context state save list‚ but instead of printing it sends it to a specified location (the first argument). The second argument is any context command but without the colon.,Use 'fetch' to retrieve and process a part of a contexts state (ie. a toggle selection).,You would need to create the object [receive new-channel] in order to view the retrieved data.,fetch d,fetch x,:v 0 :x 1 3 4 :d 3 :pr 2
find,,,% %...,% = float = ID number or symbol = tag,general,n/a,locate context ID numbers and toggles on the canvas,no,no,This helps you locate lost numbers on a larger canvas. ID numbers‚ toggle floats and tags are all searched. Very handy!,Note that this command is much more useful when it is sent to all contexts ( [s context] ) rather than one individual context‚ as in the example.,,find 1 6,find my-tag,:v 0 :x 1 2 3 4 5 :y 1 2 3 :i 1.5 2.5 3.5 4.5 5.5 :j 6.5 7.5 8.5 :n my-tag :pr 2
rev,,,%,% = float = state (0‚ 1),time,0,reverse the Context cycle,no,negative float-atom value,1 reverses the Context cycle‚ ensuring that the burst fires before tthe pattern and the pattern cycles in reverse. 0 puts it back to its normal cycle. No argument (just 'rev' or 'rev bang') toggles reverse‚ depending on the current state.,Use this to reverse the Context cycle. Note that it is functionally equivalent to selecting a negative :d value.,Note that :rd is on here to allow the loop to continue in reverse.,rev,rev 1,:v 0 :x 5 :i 5 1.5 :d 1 :pr 2 :rd 1 start :z 0
reset,-all,,,,saving,n/a,reset the context state to default,no,no,This resets the context to the familiar green‚ 5x4 default. The ID number remains.,It's 'reset' that is being used in this patch to reset the example context each time a new command box is selected.,,reset -all,,:v 0 :X 6 :Y 5 :c 19 :d 4 :a message :pr 2
reset,,,% %,% = symbol = command letter,saving,n/a,reset the specified settings,no,no,This resets only the settings specified. Note that the arguments are command letters without the colon (ie. 'g' instead of ':g').,,,reset X d,reset c x,:v 0 :X 7 :c 2 :d 3 :x 1 2 3 4 :pr 2
savelist,,,,,saving,n/a,open a text dialogue to manually edit the entire context state,other → state → edit list,no,This opens a text dialogue box with the entire context state‚ for viewing and editing.,,,savelist,,:v 0
stop,,:st,,,operation,n/a,stop the context cycle,no,click and hold on the coloured context canvas area,This stops context immediately.,,,start,stop,:v 0 :x 5 :i 5 1.5 :d 1 :s :pr 2
stop,,,% %...,% = symbol = ID (tag or number),operation,n/a,stop a set of contexts,no,no,This should work in combination with any other 'stop' command. Note that the 'context' tag is useful here for stopping all contexts.,Use this to stop any group of contexts‚ according to ID number or tag.,This will stop all contexts currently cycling‚ not just the example one.,start,stop context,:v 0 :x 5 :i 5 1.5 :d 1 :s :pr 2
stop,*,,,,operation,n/a,stop a context at the end of its cycle,no,no,This waits until the context cycle is finished and then stops it. It should work in combination with any other 'stop' command.,Use this to bring a context network to a soft stop rather than a hard.,Press the 'stop *' message before the end of the cycle and watch it finish.,start,stop *,:v 0 :x 5 :i 5 1.5 :d 1 :s :pr 2
stop,-,,% %...,% = symbol = ID (tag or number),operation,n/a,stop contexts with exceptions,no,no,This stops a context unless one of its arguments matches the context ID. It should work in combination with any other 'stop' command.,This command is very useful for creating a 'solo'.,'stop – 1' wont stop the context because ID 1 is treated as an exception. This command is much more useful when you are sending the 'stop message to a group of contexts through tag receive channels. For instance‚ 'stop – drums' being sent to [send context] would stop all contexts other than those tagged with 'drums'. This is very useful for creating 'solos'.,stop - 2,stop - 1,:v 0 :x 5 :i 5 1.5 :d 1 :pr 2
marker,,,%1  %2…,%1 = float = marker ID‚ %2... = any marker message,overlay,n/a,send message to embedded marker,no,no,Use this to send commands to any Marker embedded inside Context. The first argument is the Marker ID number. Next follows any Marker command.,Remember to use quotation marks around the Marker command.,No example given—see 'marker-help.pd'.,,,:v 0
content,,,%1  %2...,%1 = symbol  = content ID‚ %2... = any content message,operation,n/a,send message to embedded content,no,no,Use this to send commands to any Content embedded inside Context. The first argument is the Content name. Next follows any Content command.,Remember to use quotation marks around the Content command.,No example given—see 'content-help.pd'.,,,:v 0
undo,,,,,bank,n/a,send commands to embedded [undo] objects,no,no,There are three 'undo' messages: 'undo'‚ 'undo [float]' and 'undo on [float]'. The first cycles through the undo objects‚ the second one jumps to a specific object‚ and the third one turns the undo objects on/off.,The [undo] object lets you create custom 'undo chains' to help you track and revert to previous Context states. You can control the [undo] object with these messages.,No example given—see 'undo-help.pd.',,,:v 0
loop,,,,,toggles,n/a,turn self looping on/off,no,no,This is just a quick shortcut using the :x and :i commands.,Use this command to loop a Context with toggle float connections.,,loop,:ss,:v 0 :d 1
copy,,,,,bank,n/a,copy command settings from one Context to another,no,no,The 'copy' command lets you copy one Contexts settings to another. You can copy any / all settings from one context to any / all others. The syntax is powerful‚ allowing for a great number of possibilities. 1. The first argument is a director‚ either 'from' or 'to'‚ specifying whether you want to copy 'from' another Context to the one receiving the 'copy' message‚ or 'to' another (from this one). If no director is specified‚ 'to' is assumed. 2. The next argument(s) are a list of floats‚ corresponding to ID numbers. If the 'from' selector was chosen‚ the list will be truncated to a float‚ and the given settings will be copied from that single Context. If 'to' is selected or implied‚ the settings will be copied to the whole list of Contexts. 3. The last argument(s) are a series of letters corresponding to the commands you wish to be copied. For instance‚ 'x i d' would copy the commands :x :i and :d. If these arguments are left blank‚ all of the Contexts settings will be copied. If they start with a tilde (~)‚ then all commands except for those listed will be copied. There is an extra‚ 'hidden feature': if no ID numbers (2) are specified‚ then the the list of ID numbers will be interpreted by which Contexts receive the 'copy command in quick succession from the first one. In this way‚ you can specify a 'copy command dynamically‚ using either [click] or [control].,'copy' works especially well in conjunction with the [click] object (see 'click-help.pd). Note that you can only copy between Contexts that are open in the same patch window. Use 'copy ~ ID' to copy all commands apart from the ID number.,No example given—see 'helpfiles/command_input.pd',,,:v 0
euclid,{x/y},,%,% = float = rhythm length,toggles,n/a,Create a Euclidean rhythm along toggle axis,no,no,'euclid' takes one float argument‚ which is the number of beats that is to be fit into the pattern. By default‚ the pattern axis will be selected‚ but you can override this by using an operator 'x' or 'y' before the number argument.,'euclid' is used to create Euclidean rhythms‚ ie. patterns that are evenly distributed as far as possible across the toggle axis. You can use the ':x -l <' and ':x -l >' commands to alter the offset. Euclidean rhythms will work best when the pattern is looped‚ but this is not a requirement for the 'euclid' command.,,euclid 4,euclid 5,:v 0 :X 13 loop :d 1 :s
--help,,-help,%,% = any command,general,n/a,query context commands,no,no,Use the --help command to query the syntax and use of any Context command. The information prints to the console‚ and is identical to that which you get in the “context_commands_all.pd” help file.,You can query any command‚ or search for special terms‚ ie. “database”. Sending the same search term repeatedly prints more information.,Press more than once on each message‚ and watch the console for help messages.,--help :i <<,--help database,:v 0
:on,,,%,% = float = state (0‚ 1),input,1,prevent Context from starting,messages → on/off → message on/off,no,When off‚ (:on 0) this prevents context from being started. All other messages will still be interpreted as normal.,Use this to mute Context‚ a bit like a 'mute' button on a mixer.,Press :on and then try to start Context.,start,:on,:v 0 :d 1
:me,,,%,% = float = state (0‚ 1),messages,1,prevent Context from sending any messages,messages → on/off → start on/off,no,When off‚ (:me 0) this prevents context from sending any messages through the send channels or outlets. Toggle-floats still operate as normal.,Use this to mute Context‚ a bit like a 'mute' button on a mixer.,You won't notice much difference in this example‚ unless you create and print your own receive channel.,start,:me,:v 0 :d 1 :x 1 2 3 4
